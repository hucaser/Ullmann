// Ullmann.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "_Matrix.cpp"
#include "GraphMaker.h"
#include <fstream>
#include <vector>
#include <iostream>
#include <assert.h>

/*
* paramete : graph Q, graph G, matrix M
* the elems in matrix M should be all 0
* ==============================
* this function is use to initial M. 
* if 1) the i-th vertex in Q has the same label as the j-th vertex in G
*    and 2) the i-th vertex has smaller vertex degree than the j-th vertex in G
* then M[i][j] set to 1.
* ===============================
* return value :  number of rows have 1 in M 
* this value is used to prune graph. if the returen-value < M.rows,
* that means the graph Q is not the subgraph of G
**/
template<typename T>
int initM(Graph& Q, Graph &G, _Matrix<T>& M)
{
		int rows = Q.size();
		int cols = G.size();
		if(rows != M.getRows() || cols != M.getCols()){
				std::cout << "Q G M not match---in initM" << std::endl;
				return 0;
		}

		int num_of_rows_have_1 = 0;
		bool cur_row_have = false;
		for(int i=0; i<rows; i++){
				cur_row_have = false;
				for(int j=0; j<cols; j++){
						if( Q[i].label == G[j].label && Q[i].edge.size() <= G[j].edge.size() ){
								M[i][j] = 1;
								if(cur_row_have){}
								else {
										cur_row_have = true;
										num_of_rows_have_1 +=1;
								}
						} else {
								// do nothing
						}
				}
		}
		return num_of_rows_have_1;
}


/*
* Function : find
* input param : matrix M, 
*						k , 
*						pos , store 
* -------------------------------------
* we have a element is M[k][pos[k]-1], we call it E
*  this function is used to check whether the elems have the same column with E
*	and their position are above E are 1 or not
*
* return value : if no elements above E is 1, return true,
*						else return false;
*/
template<typename T>
bool find(_Matrix<T> &M, int *pos, int k)
{
		for(int i=0; i<k; i++){
				// the above floor has the same position
				if(pos[i] == pos[k]) return false;
		}
		return true;
}


/*
* Function : getM
* input param : Matrix M
* return value : array of Matrixs. Each elem in the array satisfy getM-condition
* --------------------------------------------------------------------
* getM-condition : the element in the array(let's call it M') is generated by systemmatically changing to 0
*								all but one of the 1's in each of the rows of M, subject to the definitory
*								condition that no column of a matrix M' may contain more than one 1.
*  when matrix m' which satisfy the getM-condition is found, put it into array
*  the return array should contain all matrixs that satisty the getM-conditon
*  @ if no matrix satisfy getM-condition, the array returned has nothing. so when you use the array,
*		you need to check wheter it is empty or not.
* 
* --------------------------------------------------------------------
* in order to save memory, each element in the return array is an int array.
* For example : an element in the return array called A,
*						A is an array, the i-th elem in A record the position in rows i,
*						that means M[i][A[i]]==1
*
* attention: the postion is from 1 to rows, not 0 to rows-1
*/
template<typename T>
std::vector<int *const> getM(_Matrix<T> &M)
{
		// 当前层K，找到第一个合格的1，若找到，so k+1
		// 找完这一行，k-1
		// 上一行的位置向下走
		std::vector<int *const> ret;
		int rows = M.getRows();
		int cols = M.getCols();
		int *pos = new int[rows];
		for(int i=0; i<rows; i++) pos[i] = 0;
		int k=0;
		while(k>=0){
				pos[k] = pos[k]+1;
				while(pos[k] <= cols && (M[k][pos[k]-1] == 0 || find(M, pos, k) == false ) ){
						pos[k]++;
				}
				// find
				if(pos[k] <= cols){
						if(k == rows-1) {
								// find the matrix satisfy getM-condition
								// build matrix m`, put it into array
								int *retp = new int[rows];
								for(int i=0; i<rows; i++) retp[i] = pos[i];
								ret.push_back(retp);
								// find next matrix
								k--;
						}
						else {
								++k;
								pos[k]==0;
						}
				} else{
						k--;
				}
				
		}

		delete[] pos;
		return ret;
}


/*
* Function : buildMatrix
* input param : a Graph Q and an all 0 matrix M, M should be a square matrix
* -----------------------------------------------------
* this function will set M[i][j] = 0, if vectex i and j are connected in Q
*/
template<typename T>
void buildMatrix(Graph& Q,  _Matrix<T>& M)
{
		int rows = Q.size();
		int cols = rows;
		if(rows != M.getRows() || cols != M.getCols()){
				std::cout << "Q  M not match---in buildMatrix" << std::endl;
				return ;
		}

		for(int i=0; i<rows; i++){
				int edge_num = Q[i].edge.size();
				for(int j=0; j < edge_num; j++){
						int to = Q[i].edge[j].to;
						assert(Q[i].edge[j].from == i);
						M[i][to]=1;
				}
		}
}


/*
* transpose Matrix
*/
template<typename T>
_Matrix<T> transposeMatrix(_Matrix<T> &M)
{
		int rows = M.getRows();
		int cols = M.getCols();

		_Matrix<T> result(cols, rows, 0);
		for(int i=0; i < rows; i++){
				for(int j=0; j<cols; j++){
						result[j][i] = M[i][j];
				}
		}
		return result;
}

/*
* ---------------------------------------------------
* this function is used to verify mp by the following 
* equation Mc = mp*(mp*MB)T
* for every i and j MA[i][j]=1 -> Mc[i][j] = 1 then return true
*/
template<typename T>
bool verifyMatrix(_Matrix<T> &MA, _Matrix<T> &MB, _Matrix<T> &mp)
{
		_Matrix<T> Mc = mp*transposeMatrix(mp*MB);
		int rows = MA.getRows();
		int cols = MA.getCols();
		bool result = true;
		for(int i=0; i<rows; i++){
				for(int j=0; j<cols;j++){
						if(MA[i][j]==1 && Mc[i][j] != 1)
								result = false;
				}
		}
		return result;
}

int _tmain(int argc, _TCHAR* argv[])
{
		_Matrix<int> m(2,2,3);
		_Matrix<int> m2(2,3,1);
		_Matrix<int> tt = m;
		m*m2;
		m[1][1] = 9;
		// store all graph in mygraphdb to mygrapdb
		char *indb = "../graphDB/mygraphdb.data";
		std::ifstream db_in(indb);
		GraphMaker mygraphdb;
		mygraphdb.readFile(db_in);

		// store all graph in Q4 to q4
		char *inquery = "../graphDB/Q4.my";
		std::ifstream q4_in(inquery);
		GraphMaker q4;
		q4.readFile(q4_in);

		// this two variable use to record current match graphs' position
		// subgraphPos is subgraph's position, parentPos is the graph's position in graphdb
		int subgraphPos = 0;
		int parentPos = 0;
		// for each graph in q4, iterately find its supergraph in mygraphdb
		typedef std::vector<Vertex>::size_type GraphSize;
		for(std::vector<Graph>::iterator i= q4.graphDatabase.begin(); i != q4.graphDatabase.end();
				i++){
						++subgraphPos;
						parentPos = 0;
						for(std::vector<Graph>::iterator j = mygraphdb.graphDatabase.begin();
								j != mygraphdb.graphDatabase.end(); j++){

								++parentPos;
								Graph& Q = *i;
								Graph& G = *j;
								GraphSize rows = Q.size();
								GraphSize cols = G.size();
								// build matrix M
								_Matrix<int> M(rows, cols, 0);
									
							
								/*
								* step 1. set M[i][j] = 1, if
								* 1) the i-th vertex in Q has the same label as the j-th vertex in G;
								* 2) the i-th vertex has smaller vertex degree than the j-th vertex in G
								**/
								int num_of_rows_have_1 = initM(Q, G, M);
								if( num_of_rows_have_1 == M.getRows()){
										// have hope
										_Matrix<int> MA(rows, rows, 0);
										_Matrix<int> MB(cols, cols, 0);
										buildMatrix(Q, MA);
										buildMatrix(G, MB);

										std::vector<int *const> array_m = getM(M);
										typedef std::vector<int *>::size_type MSIZE;
										for(MSIZE i=0; i < array_m.size(); i++){
												// print position
												//for(int j = 0; j < M.getRows(); j++) printf("%d  ",array_m[i][j]);
												// build matrix m'
												_Matrix<int> mp(rows, cols, 0);
												// be careful, you must sub 1
												for(int j = 0; j < M.getRows(); j++) mp[j][array_m[i][j]-1]=1;
												// matrix operate
												bool is_subgraph = verifyMatrix(MA, MB, mp);
												if(is_subgraph){
														printf("%d-th graph in %s is the subgraph of %d-th graph in %s\n",
																subgraphPos, inquery, parentPos, indb);
														delete[] array_m[i];
														break;
												}
												// void memory leak
												delete[] array_m[i];
										}
								}
						}
		}
	system("pause");
	return 0;
}

